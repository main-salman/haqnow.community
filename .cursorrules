# Cursor Rules for Haqnow Community Platform

## Core Development Rules

## CUSTOM
- use start-local.sh to start local dev test environment to test features locally
- update start-local.sh whenever needed as features are added and changes are made to ensure that it continues to work for local developement
- deploy-to-server.sh should always copy .env file from my workstation to the server, then run git commit, and then download the code from github on the server to deploy the latest code. Code should always only be downloaded from github. Keep deploy-to-server.sh updated so that whenever new changes are made to application architecture, deploy-to-server.sh works properly to deploy the application appropriately.

### 1. Testing Requirements
- **MANDATORY**: Every new feature implementation MUST include automated tests
- Tests must be written simultaneously with the feature, not after
- All tests must pass before any commit is made
- Test coverage should be maintained at a high level
- Use pytest for backend testing (already configured in pyproject.toml)
- Tests should cover:
  - Happy path scenarios
  - Edge cases and error conditions
  - Authentication and authorization
  - API endpoints and data validation
  - Database operations

### 2. Documentation Requirements
- **MANDATORY**: Update README.md with every new feature
- README.md must include:
  - New feature descriptions
  - Architecture changes or updates
  - API endpoint documentation
  - Setup and deployment instructions
  - Environment configuration changes
- Keep architecture.txt updated with significant architectural changes
- Document any new environment variables or configuration options

### 3. Git Workflow and Automation
- Set up pre-commit hooks to run tests automatically
- All commits must pass the test suite
- Use conventional commit messages (feat:, fix:, docs:, test:, etc.)
- No direct commits to main branch without passing tests

## Code Quality Standards

### 4. Engineering Excellence
- Work like a 10x/senior engineer
- Always prefer simple, elegant solutions
- Avoid code duplication - check for existing similar functionality first
- Write environment-aware code (dev, test, prod)
- Only make changes that are requested or clearly related to the task
- When fixing bugs, exhaust existing implementation options before introducing new patterns

### 5. Code Organization
- Keep codebase clean and well-organized
- Avoid files over 200-300 lines - refactor when approaching this limit
- No scripts in files unless absolutely necessary
- Remove old implementations when introducing new patterns
- Follow existing project structure and naming conventions

### 6. Data and Environment Management
- Mocking data is ONLY for tests, never for dev or prod
- Never add stubbing or fake data patterns to dev/prod code
- Use proper environment configuration for different stages
- Maintain separation between test, dev, and production data

## Project-Specific Rules

### 7. Backend Development (FastAPI/Python)
- Follow FastAPI best practices
- Use SQLAlchemy for database operations
- Implement proper error handling and validation
- Use Pydantic schemas for data validation
- Follow the existing route organization pattern
- Maintain proper authentication and authorization

### 8. Infrastructure and Deployment
- Update Terraform configurations when infrastructure changes
- Maintain docker-compose.yml for local development
- Document any new infrastructure requirements
- Follow the existing module structure in infra/terraform/

### 9. Security
- Never commit sensitive data or credentials
- Use proper environment variables for configuration
- Implement proper authentication and authorization
- Follow security best practices for API development
- Validate all inputs and sanitize outputs

### 10. Continuous Integration
- Tests must run on every commit
- Set up GitHub Actions or similar CI/CD pipeline
- Automated deployment should only happen after all tests pass
- Maintain build and deployment scripts

## File Management

### 11. History Tracking
- Keep updating history.txt with all changes
- Never delete content from history.txt
- Learn from previous changes to avoid repetition
- Document lessons learned and decisions made

### 12. Dependencies
- Keep poetry.lock updated
- Document new dependencies and their purpose
- Regularly update dependencies for security
- Use specific version ranges in pyproject.toml

## Enforcement

These rules are enforced through:
- Pre-commit hooks (to be set up)
- Automated testing on commit
- Code review requirements
- Documentation review process

## Getting Started

To set up the development environment with these rules:

1. Install pre-commit hooks: `pre-commit install`
2. Run tests before any commit: `cd backend && poetry run pytest`
3. Update documentation with every feature
4. Follow the conventional commit format
5. Ensure all tests pass before pushing

Remember: Quality over speed. It's better to deliver fewer, well-tested features than many buggy ones.

## Cursor Token Budget Optimization

To minimize tokens, scope searches narrowly and use the README quick maps as your first stop.

- Primary references
  - Use `README.md` → sections "Architecture Quick Map" and "Common Files and Tasks Map" to determine EXACT files/dirs to inspect before scanning broadly.
  - Use `architecture.txt` only for deep design context; do not read it unless necessary.

- Directory scoping defaults
  - Backend focus: prefer `backend/app/` or specific files inside it (e.g., `backend/app/routes_documents.py`, `backend/app/security.py`).
  - Frontend focus: prefer `frontend/src/` or specific files inside it (e.g., `frontend/src/services/api.ts`, `frontend/src/pages/`).
  - Tests: prefer `backend/tests/` when validating behavior.

- Avoid scanning these unless explicitly required
  - `backend/chroma_db/` (binary/vector index data)
  - `backend/uploads/` (user/local files)
  - Large assets in repo root (e.g., PDFs, images)
  - `frontend/public/` for code searches
  - Dependency locks and build artifacts (`poetry.lock`, `package-lock.json`, `dist/`, `node_modules/`)

- Search heuristics
  - Start with semantic search scoped to a single directory from the quick maps. Only widen after two misses.
  - Use exact-text search only for symbols or file names you already know (e.g., `routes_documents.py`).
  - Limit parallel searches to 3–5 targeted queries, each with a concrete question ("Where is X validated?", not just a keyword).
  - Prefer reading individual files called out in README over listing directories.
  - When reading large files, read only the needed sections; avoid full-file reads unless necessary.

- Operational notes
  - Use absolute paths where possible.
  - Skip binary/non-text files.
  - When proposing code edits, touch only the files named in README quick maps unless the change requires broader refactors.
  - After any edit, run only the relevant tests (see `backend/tests/` mapping in README) before broader runs.
